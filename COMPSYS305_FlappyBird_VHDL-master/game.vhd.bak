LIBRARY IEEE;
USE IEEE.STD_LOGIC_1164.all;
USE IEEE.STD_LOGIC_ARITH.all;
USE IEEE.STD_LOGIC_SIGNED.all;

ENTITY game IS
Generic(ADDR_WIDTH: integer := 12; DATA_WIDTH: integer := 1);
   PORT(	clk											: IN STD_LOGIC;
			ball_on										: IN STD_LOGIC;
			Ball_Dead									: IN STD_LOGIC;
			pipe_on										: IN STD_LOGIC_VECTOR(1 DOWNTO 0);
			rom_mux										: IN STD_LOGIC;
			sw0, sw1, sw9								: IN STD_LOGIC;
			bt2, bt1, bt0								: IN STD_LOGIC;
			left_click									: IN STD_LOGIC;
			right_click									: IN STD_LOGIC;
			red_data, green_data, blue_data		: OUT STD_LOGIC_VECTOR(3 DOWNTO 0);
			Game_Reset,Score_Reset				   : OUT STD_LOGIC;
			Game_Enable									: OUT STD_LOGIC;
			Game_States									: OUT STD_LOGIC_VECTOR(1 DOWNTO 0));
END game;

architecture behavior of game is

TYPE GAME_STATE is (WELCOME, GAME, PRACTICE, GAME_END);
signal CS: GAME_STATE := WELCOME;

SIGNAL prev_left_click	 : std_logic := '1';
SIGNAL prev_right_click	 : std_logic := '1';
SIGNAL red_data_t  		 : std_logic_vector(3 downto 0) := "1111";
SIGNAL green_data_t		 : std_logic_vector(3 downto 0) := "1111";
SIGNAL blue_data_t 		 : std_logic_vector(3 downto 0) := "1111";
SIGNAL prev_bt0	 		 : std_logic := '1';
SIGNAL prev_bt1	 		 : std_logic := '1';
SIGNAL prev_bt2	 		 : std_logic := '1';

BEGIN			 

GAME_STATES_REG: Process(CS, sw0, bt2, bt1, sw9, left_click, right_click, Ball_Dead, clk)
BEGIN
	
	IF (sw9 = '1') THEN
		CS <= WELCOME;
	ELSIF (clk'event AND clk = '1') THEN
		CASE CS IS
			WHEN WELCOME => 
				IF ((bt2 = '0') AND (prev_bt2 = '1')) OR ((left_click = '1') AND (prev_left_click = '0')) THEN
					IF (sw0 = '1') THEN
						CS <= GAME;
					ELSE
						CS <= PRACTICE;
					END IF;
				ELSE
					CS <= CS;
				END IF;
			WHEN GAME => 
				IF (Ball_Dead = '1') THEN
					CS <= GAME_END;
				ELSE
					CS <= CS;
				END IF;
			WHEN PRACTICE => 
				IF (bt1 = '0') AND (prev_bt1= '1') THEN
					CS <= GAME_END;
				ELSE
					CS <= CS;
				END IF;
			WHEN GAME_END =>  
				IF ((bt0 = '0') AND (prev_bt0 = '1')) OR ((right_click = '1') AND (prev_right_click = '0')) THEN	
					CS <= WELCOME;
				ELSE 
					CS <= CS;
				END IF;
		END CASE;
		prev_bt0 <= bt0;
		prev_bt1 <= bt1;
		prev_bt2 <= bt2;
		prev_left_click <= left_click;
		prev_right_click <= right_click;
	END IF;
END PROCESS GAME_STATES_REG;	

OUT_LOGIC: Process(CS) -- ouput logic of each state
BEGIN
	CASE CS IS
		WHEN WELCOME =>	
						Game_States <= "00";
						Game_Reset 	<= '1';
						Score_Reset <= '1';
						Game_Enable <= '0';
		WHEN GAME =>
						Game_States <= "01";
						Game_Reset 	<= '0';
						Score_Reset <= '0';
						Game_Enable <= '1';
		WHEN PRACTICE =>
						IF (Ball_Dead = '1') THEN
							Score_Reset <= '1';
						ELSE
							Score_Reset <= '0';
						END IF;
						Game_States <= "10";
						Game_Reset 	<= '0';
						Game_Enable <= '1';
		WHEN GAME_END =>	
						Game_States <= "11";
						Game_Reset 	<= '0';
						Score_Reset <= '0';
						Game_Enable <= '0';
	END CASE;	
END PROCESS OUT_LOGIC;

RGB_Switch: Process (Ball_on, Pipe_on, rom_mux, CS)
BEGIN	
	IF (rom_mux = '1') THEN
		Red_Data_t <= "1111";
		Green_Data_t <= "0000";
		Blue_Data_t <= "0000";
	ELSIF (Ball_on = '1') THEN -- when rendering ball
		Red_Data_t <= "0000";
		Green_Data_t <= "1111";
		Blue_Data_t <= "1111";	
	ELSIF (Pipe_on(0) = '1') THEN -- when rendering pipe 0
		Red_Data_t <= "1111";
		Green_Data_t <= "1111";
		Blue_Data_t <= "1111";
	ELSIF Pipe_on(1) = '1' THEN -- when rendering pipe 1
		Red_Data_t <= "1111";
		Green_Data_t <= "1111";
		Blue_Data_t <= "1111";
	ELSE -- when rendering back ground
		Red_Data_t <= "1111";
		Green_Data_t <= "1111";
		Blue_Data_t <= "0000";
	END IF;
END PROCESS RGB_Switch;

Red_Data <= Red_Data_t;
Green_Data <= Green_Data_t;
Blue_Data <= Blue_Data_t;

END behavior;